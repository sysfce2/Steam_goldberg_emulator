name: Create release info json

on:
  release:
    types: [published, prereleased]

jobs:
  generate-release-json:
    runs-on: windows-latest

    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
          fetch-depth: 0
          #submodules: recursive

    - name: Get release info
      id: get_release_info
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        $release = (Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository_owner }}/${{ github.event.repository.name }}/releases/tags/${{ github.event.release.tag_name }}" -Headers @{"Authorization"="token ${{ secrets.GITHUB_TOKEN }}"})
        rel_name = $release.name
        echo "name=$rel_name" >> $GITHUB_ENV
        rel_tag=$release.tag_name
        echo "tag=$rel_tag" >> $GITHUB_ENV
        rel_branch = $(git branch -r --contains $commit_sha | Select-String -Pattern 'origin/' | ForEach-Object { $_.ToString().Trim() -replace 'origin/', '' } | Sort-Object -Descending | Select-Object -First 1)
        echo "branch=$rel_branch" >> $GITHUB_ENV
        rel_commit = $(git rev-list -n 1 $env:GITHUB_REF)
        echo "commit=$rel_commit" >> $GITHUB_ENV
        #echo "commit=$($release.target_commitish)" >> $GITHUB_ENV
        rel_date = $release.published_at.ToString("yyyy-MM-ddTHH:mm:ssZ").Split("T")[0]
        echo "date=$rel_date" >> $GITHUB_ENV
        #echo "date=$([datetime]::Parse($release.published_at)).ToString('yyyy-MM-dd')" >> $GITHUB_ENV
        rel_time = $release.published_at.ToString("yyyy-MM-ddTHH:mm:ssZ").Split("T")[1].Split("Z")[0]
        echo "time=$rel_time" >> $GITHUB_ENV
        #echo "time=$([datetime]::Parse($release.published_at)).ToString('HH:mm:ss')" >> $GITHUB_ENV
        echo "Release Name: $env:name"
        echo "Release Tag: $env:tag"
        echo "Branch: $env:branch"
        echo "Commit: $env:commit"
        echo "Date: $env:date"
        echo "Time: $env:time"
      shell: pwsh

    - name: Validate environment variables
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        if (-not $env:name) { throw "Missing release name" }
        if (-not $env:tag) { throw "Missing release tag" }
        if (-not $env:branch) { throw "Missing release branch" }
        if (-not $env:commit) { throw "Missing release commit" }
        if (-not $env:date) { throw "Missing release date" }
        if (-not $env:time) { throw "Missing release time" }
      shell: pwsh

    - name: Checkout release branch
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        git fetch origin
        git checkout $env:branch
      shell: pwsh

    - name: Ensure branch is writable
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        $branchStatus = git status
        if ($branchStatus -match 'Your branch is up to date with') {
          echo "Branch $env:branch is writable."
        } else {
          throw "Branch $env:branch is not writable."
        }
      shell: pwsh

    - name: Generate JSONs
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases"
        $sortedReleases = $releases | Sort-Object {[datetime]::Parse($_.published_at)} -Descending
        $owner = '${{ github.repository_owner }}'
        $repo = '${{ github.event.repository.name }}'
        $releaseObjs = $sortedReleases | Where-Object { -not $_.prerelease } | ForEach-Object {
          $downloads = $_.assets | ForEach-Object {
            [PSCustomObject]@{
              name   = $_.name
              url    = $_.browser_download_url
              count  = $_.download_count
            }
          }
          [PSCustomObject]@{
            owner    = $owner
            repo     = $repo
            branch   = $_.target_commitish
            commit   = $_.commit.sha
            details  = [PSCustomObject]@{
              name      = $_.name
              tag       = $_.tag_name
              date      = ([datetime]::Parse($_.published_at)).ToString('yyyy-MM-dd')
              time      = ([datetime]::Parse($_.published_at)).ToString('HH:mm:ss')
              downloads = $downloads
            }
          }
        }
        $prereleaseObjs = $sortedReleases | Where-Object { $_.prerelease } | ForEach-Object {
          $downloads = $_.assets | ForEach-Object {
            [PSCustomObject]@{
              name   = $_.name
              url    = $_.browser_download_url
              count  = $_.download_count
            }
          }
          [PSCustomObject]@{
            owner    = $owner
            repo     = $repo
            branch   = $_.target_commitish
            commit   = $_.commit.sha
            details  = [PSCustomObject]@{
              name      = $_.name
              tag       = $_.tag_name
              date      = ([datetime]::Parse($_.published_at)).ToString('yyyy-MM-dd')
              time      = ([datetime]::Parse($_.published_at)).ToString('HH:mm:ss')
              downloads = $downloads
            }
          }
        }
        $releaseObjs | ConvertTo-Json -Depth 100 > releases.json
        $prereleaseObjs | ConvertTo-Json -Depth 100 > prereleases.json
      shell: pwsh

    - name: Commit and force push JSONs
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $ErrorActionPreference = "Stop"
        $VerbosePreference = "Continue"
        git config --global user.name '${{ github.actor }}'
        git config --global user.email '${{ github.actor }}@users.noreply.github.com'
        if (Test-Path -Path releases.json) {
          git add releases.json
        }
        if (Test-Path -Path prereleases.json) {
          git add prereleases.json
        }
        git commit --amend --no-edit
        git push --force-with-lease
        #git push -f origin $env:branch
      shell: pwsh
